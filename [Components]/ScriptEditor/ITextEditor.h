#pragma once
#include "SemanticAnalysis.h"
#include "IIntelliSenseInterface.h"
#include "[Common]\NativeWrapper.h"

namespace cse
{


namespace scriptEditor
{


namespace textEditor
{


ref class TextEditorScriptModifiedEventArgs : public EventArgs
{
public:
	property bool ModifiedStatus;

	TextEditorScriptModifiedEventArgs(bool ModifiedStatus);
};
delegate void TextEditorScriptModifiedEventHandler(Object^ Sender, TextEditorScriptModifiedEventArgs^ E);

ref class TextEditorMouseClickEventArgs : public MouseEventArgs
{
public:
	property int ScriptTextOffset;

	TextEditorMouseClickEventArgs(MouseButtons Button, int Clicks, int X, int Y, int ScriptTextOffset);
};
delegate void TextEditorMouseClickEventHandler(Object^ Sender, TextEditorMouseClickEventArgs^ E);

interface class ILineAnchor
{
	property UInt32 Line;
	property bool Valid;
};

static enum class eFindReplaceOperation
{
	Find,
	Replace,
	CountMatches
};

[Flags]
static enum class eFindReplaceOptions
{
	None			= 0,
	InSelection		= 1 << 0,
	MatchWholeWord	= 1 << 1,
	CaseInsensitive	= 1 << 2,
	RegEx			= 1 << 3,
	IgnoreComments	= 1 << 4
};

ref struct FindReplaceResult
{
	ref struct HitData
	{
		UInt32 Line;
		String^ Text;		// the line's text after replacement
		UInt32 Hits;		// no of hits in the line

		HitData(UInt32 Line, String^ Text, UInt32 Hits);
	};

	List<HitData^>^ Hits;
	bool HasError;

	FindReplaceResult();

	property int TotalHits
	{
		int get();
	}

	void Add(UInt32 Line, String^ Text, UInt32 HitsInLine);
};

interface class ITextEditor : public intellisense::IIntelliSenseInterfaceConsumer
{
	event TextEditorScriptModifiedEventHandler^ ScriptModified;
	event KeyEventHandler^ KeyDown;
	event TextEditorMouseClickEventHandler^ MouseClick;
	event EventHandler^ LineChanged;			// raised when the current line changes
	event EventHandler^ TextUpdated;			// raised after the editor's entire text has been updated
	event EventHandler^ LineAnchorInvalidated;	// raised when an active line anchor generated by this editor gets invalidated

	property Control^ Container;
	property IntPtr WindowHandle;
	property bool Enabled;
	property int CurrentLine;
	property int LineCount;
	property int Caret;
	property bool Modified;

	// methods
	void Bind();	// called when the parent model is bound to a view, i.e., when the text editor is activated
	void Unbind();	// opposite of the above

	String^ GetText();
	String^ GetText(UInt32 LineNumber);
	void SetText(String^ Text, bool ResetUndoStack);
	String^ GetSelectedText(void);
	void SetSelectedText(String^ Text);
	int GetCharIndexFromPosition(Point Position);
	Point GetPositionFromCharIndex(int Index, bool Absolute);
	String^ GetTokenAtCharIndex(int Offset);
	String^ GetTokenAtCaretPos();
	void SetTokenAtCaretPos(String^ Replacement);
	void ScrollToCaret();
	void ScrollToLine(UInt32 LineNumber);
	void FocusTextArea();

	void LoadFileFromDisk(String^ Path);
	void SaveScriptToDisk(String^ Path, bool PathIncludesFileName, String^ DefaultName, String^ DefaultExtension);

	FindReplaceResult^ FindReplace(eFindReplaceOperation Operation, String^ Query, String^ Replacement, eFindReplaceOptions Options);

	void BeginUpdate(void);
	void EndUpdate(bool FlagModification);

	UInt32 GetIndentLevel(UInt32 LineNumber);
	void InsertVariable(String^ VariableName, obScriptParsing::Variable::DataType VariableType);

	void InitializeState(String^ ScriptText, int CaretPosition);
	ILineAnchor^ CreateLineAnchor(UInt32 Line);

	void InvokeDefaultCopy();
	void InvokeDefaultPaste();
	void CommentLine(UInt32 Line);
	void CommentSelection();
	void UncommentLine(UInt32 Line);
	void UncommentSelection();
};


} // namespace textEditor


} // namespace scriptEditor


} // namespace cse